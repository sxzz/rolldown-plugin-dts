// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`basic 1`] = `
"// basic.d.ts
//#region tests/fixtures/basic.d.ts
declare const foo: number;
type SomeType<T> = T;
type FooType = string;
interface Interface {}
declare function fn(arg0: SomeType<FooType>, opt: Interface): void;
declare enum Enum {
  A = 0,
  B = 1,
  C = 2,
}
declare class Cls {
  foo: string;
  fn(e: Enum): void;
}
//#endregion
export { Cls, Enum, fn, foo };
// basic.js
//#region tests/fixtures/basic.ts
const foo = 42;
function fn(arg0, opt) {}
let Enum = /* @__PURE__ */ function(Enum$1) {
	Enum$1[Enum$1["A"] = 0] = "A";
	Enum$1[Enum$1["B"] = 1] = "B";
	Enum$1[Enum$1["C"] = 2] = "C";
	return Enum$1;
}({});
var Cls = class {
	foo;
	fn(e) {}
};

//#endregion
export { Cls, Enum, fn, foo };"
`;

exports[`dts input 1`] = `
"// index.d.ts
//#region tests/fixtures/dts-input.d.ts
declare class Foo {}

//#endregion
export { Foo };"
`;

exports[`input alias 1`] = `
"// input2-DX9os_AR.d.ts
//#region shared.d.ts
interface Shared {
  shared: string;
}
declare const shared: Shared;
//#endregion
//#region input2.d.ts
interface Input2 extends Shared {
  input2: string;
}
declare const input2: Input2;

//#endregion
export { Input2, input2 as input2$1 };
// input2-LCiYuoaZ.js
//#region shared.ts
const shared = { shared: "shared" };

//#endregion
//#region input2.ts
const input2 = {
	...shared,
	input2: "input2"
};

//#endregion
export { input2 };
// output1.d.ts
import { Input2 } from "./input2-DX9os_AR.js";

//#region input1.d.ts
interface Input1 extends Input2 {
  input1: string;
}
declare const input1: Input1;

//#endregion
export { Input1, input1 };
// output1.js
import { input2 } from "./input2-LCiYuoaZ.js";

//#region input1.ts
const input1 = {
	...input2,
	input1: "input1"
};

//#endregion
export { input1 };
// output2/index.d.ts
import { Input2, input2$1 as input2 } from "../input2-DX9os_AR.js";
export { Input2, input2 };
// output2/index.js
import { input2 } from "../input2-LCiYuoaZ.js";

export { input2 };"
`;

exports[`jsdoc 1`] = `
"// jsdoc.d.ts
//#region tests/fixtures/jsdoc.d.ts
/**
 * named export
 */
declare function fn(): number;
/**
 * options
 */
interface Options {
  /**
   * interface member
   */
  foo: string;
}
/**
 * type alias
 */
type Foo = string;
/**
 * default export
 */
declare const _default: number; //#endregion
export { Foo, Options, _default as default, fn };
// jsdoc.js
//#region tests/fixtures/jsdoc.ts
/**
* named export
*/
function fn() {
	return 42;
}
/**
* default export
*/
var jsdoc_default = fn();

//#endregion
export { jsdoc_default as default, fn };"
`;

exports[`paths 1`] = `
"// index.d.ts
//#region tests/fixtures/paths/mod.d.ts
declare const foo = 42;

//#endregion
export { foo };"
`;

exports[`resolve dts 1`] = `
"// index.d.ts
//#region tests/fixtures/resolve-dts/mod.d.ts
type Foo = string;

//#endregion
export { Foo };
// index.js
"
`;

exports[`tree-shaking 1`] = `
"// index.d.ts
//#region tests/fixtures/tree-shaking/mod.d.ts

type A = string;
//#endregion
export { A };
// index.js
"
`;

exports[`tsx 1`] = `
"// tsx.d.ts
import { JSX } from "solid-js";

//#region tests/fixtures/tsx.d.ts
declare function createComponent(): JSX.HTMLAttributes<HTMLElement>;

//#endregion
export { createComponent };
// tsx.js
import { jsx } from "react/jsx-runtime";

//#region tests/fixtures/tsx.tsx
function createComponent() {
	return /* @__PURE__ */ jsx("div", {});
}

//#endregion
export { createComponent };"
`;

exports[`typescript compiler 1`] = `
"// entry1.d.ts

declare const str = "foo";
declare const num = 42;
declare const bool = true;
declare function fn(arg: typeof str): "foo" | 1;

//#endregion

declare const vfs: number;

//#endregion
export { bool, fn, num, str, vfs };
// entry2.d.ts

interface Unused {
  foo: string;
}
//#endregion
export { Unused };"
`;

exports[`vue-sfc w/ ts-compiler 1`] = `
"// main.d.ts
import { GlobalComponents, GlobalDirectives, ObjectDirective, ShallowRef, unref } from "vue";
import { JSX } from "vue/jsx-runtime";

//#region tests/fixtures/vue-sfc/App.vue.d.ts
declare const _default: any;
declare global {
    const __VLS_intrinsicElements: __VLS_IntrinsicElements;
    const __VLS_directiveBindingRestFields: {
        instance: null;
        oldValue: null;
        modifiers: any;
        dir: any;
    };
    const __VLS_unref: typeof unref;
    const __VLS_placeholder: any;
    type __VLS_NativeElements = __VLS_SpreadMerge<SVGElementTagNameMap, HTMLElementTagNameMap>;
    type __VLS_IntrinsicElements = JSX.IntrinsicElements;
    type __VLS_Element = JSX.Element;
    type __VLS_GlobalComponents = GlobalComponents;
    type __VLS_GlobalDirectives = GlobalDirectives;
    type __VLS_IsAny<T> = 0 extends 1 & T ? true : false;
    type __VLS_PickNotAny<A, B> = __VLS_IsAny<A> extends true ? B : A;
    type __VLS_SpreadMerge<A, B> = Omit<A, keyof B> & B;
    type __VLS_WithComponent<N0 extends string, LocalComponents, Self, N1 extends string, N2 extends string, N3 extends string> = N1 extends keyof LocalComponents ? N1 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : {
        [K in N0]: LocalComponents[N1];
    } : N2 extends keyof LocalComponents ? N2 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : {
        [K in N0]: LocalComponents[N2];
    } : N3 extends keyof LocalComponents ? N3 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : {
        [K in N0]: LocalComponents[N3];
    } : Self extends object ? {
        [K in N0]: Self;
    } : N1 extends keyof __VLS_GlobalComponents ? N1 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : {
        [K in N0]: __VLS_GlobalComponents[N1];
    } : N2 extends keyof __VLS_GlobalComponents ? N2 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : {
        [K in N0]: __VLS_GlobalComponents[N2];
    } : N3 extends keyof __VLS_GlobalComponents ? N3 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : {
        [K in N0]: __VLS_GlobalComponents[N3];
    } : {
        [K in N0]: unknown;
    };
    type __VLS_FunctionalComponentProps<T, K> = '__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends {
        __ctx?: {
            props?: infer P;
        };
    } ? NonNullable<P> : never : T extends (props: infer P, ...args: any) => any ? P : {};
    type __VLS_IsFunction<T, K> = K extends keyof T ? __VLS_IsAny<T[K]> extends false ? unknown extends T[K] ? false : true : false : false;
    type __VLS_NormalizeComponentEvent<Props, Events, onEvent extends keyof Props, Event extends keyof Events, CamelizedEvent extends keyof Events> = (__VLS_IsFunction<Props, onEvent> extends true ? Props : __VLS_IsFunction<Events, Event> extends true ? {
        [K in onEvent]?: Events[Event];
    } : __VLS_IsFunction<Events, CamelizedEvent> extends true ? {
        [K in onEvent]?: Events[CamelizedEvent];
    } : Props) & Record<string, unknown>;
    type __VLS_UnionToIntersection<U> = (U extends unknown ? (arg: U) => unknown : never) extends ((arg: infer P) => unknown) ? P : never;
    type __VLS_OverloadUnionInner<T, U = unknown> = U & T extends (...args: infer A) => infer R ? U extends T ? never : __VLS_OverloadUnionInner<T, Pick<T, keyof T> & U & ((...args: A) => R)> | ((...args: A) => R) : never;
    type __VLS_OverloadUnion<T> = Exclude<__VLS_OverloadUnionInner<(() => never) & T>, T extends () => never ? never : () => never>;
    type __VLS_ConstructorOverloads<T> = __VLS_OverloadUnion<T> extends infer F ? F extends (event: infer E, ...args: infer A) => any ? {
        [K in E & string]: (...args: A) => void;
    } : never : never;
    type __VLS_NormalizeEmits<T> = __VLS_PrettifyGlobal<__VLS_UnionToIntersection<__VLS_ConstructorOverloads<T> & {
        [K in keyof T]: T[K] extends any[] ? {
            (...args: T[K]): void;
        } : never;
    }>>;
    type __VLS_PrettifyGlobal<T> = {
        [K in keyof T]: T[K];
    } & {};
    type __VLS_PickFunctionalComponentCtx<T, K> = NonNullable<__VLS_PickNotAny<'__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends {
        __ctx?: infer Ctx;
    } ? Ctx : never : any, T extends (props: any, ctx: infer Ctx) => any ? Ctx : any>>;
    type __VLS_OmitStringIndex<T> = {
        [K in keyof T as string extends K ? never : K]: T[K];
    };
    type __VLS_UseTemplateRef<T> = Readonly<ShallowRef<T | null>>;
    function __VLS_getVForSourceType<T extends number | string | any[] | Iterable<any>>(source: T): [
        item: T extends number ? number : T extends string ? string : T extends any[] ? T[number] : T extends Iterable<infer T1> ? T1 : any,
        index: number
    ][];
    function __VLS_getVForSourceType<T>(source: T): [
        item: T[keyof T],
        key: keyof T,
        index: number
    ][];
    function __VLS_getSlotParams<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>;
    function __VLS_getSlotParam<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>[0];
    function __VLS_asFunctionalDirective<T>(dir: T): T extends ObjectDirective ? NonNullable<T['created' | 'beforeMount' | 'mounted' | 'beforeUpdate' | 'updated' | 'beforeUnmount' | 'unmounted']> : T extends (...args: any) => any ? T : (arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown) => void;
    function __VLS_makeOptional<T>(t: T): {
        [K in keyof T]?: T[K];
    };
    function __VLS_asFunctionalComponent<T, K = T extends new (...args: any) => any ? InstanceType<T> : unknown>(t: T, instance?: K): T extends new (...args: any) => any ? (props: (K extends {
        $props: infer Props;
    } ? Props : any) & Record<string, unknown>, ctx?: any) => __VLS_Element & {
        __ctx?: {
            attrs?: any;
            slots?: K extends {
                $slots: infer Slots;
            } ? Slots : any;
            emit?: K extends {
                $emit: infer Emit;
            } ? Emit : any;
            expose?(exposed: K): void;
            props?: (K extends {
                $props: infer Props;
            } ? Props : any) & Record<string, unknown>;
        };
    } : T extends () => any ? (props: {}, ctx?: any) => ReturnType<T> : T extends (...args: any) => any ? T : (_: {} & Record<string, unknown>, ctx?: any) => {
        __ctx?: {
            attrs?: any;
            expose?: any;
            slots?: any;
            emit?: any;
            props?: {} & Record<string, unknown>;
        };
    };
    function __VLS_functionalComponentArgsRest<T extends (...args: any) => any>(t: T): 2 extends Parameters<T>['length'] ? [any] : [];
    function __VLS_asFunctionalElement<T>(tag: T, endTag?: T): (attrs: T & Record<string, unknown>) => void;
    function __VLS_asFunctionalSlot<S>(slot: S): (props: NonNullable<S> extends (props: infer P) => any ? P : {}) => void;
    function __VLS_tryAsConstant<const T>(t: T): T;
}

//#endregion
export { _default as App };"
`;
