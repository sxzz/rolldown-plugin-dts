// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`ambient declarations in node_modules 1`] = `
"// index.d.ts
//#region node_modules/ambient-lib/index.d.ts
interface PublicApi {
  name: string;
}
interface AmbientConnection {
  host: string;
  port: number;
}
interface AmbientConfig {
  timeout: number;
  retries: number;
}
declare class AmbientDatabase {
  connection: AmbientConnection;
  query(sql: string): Promise<unknown>;
}
//#endregion
//#region index.d.ts
interface MyService {
  api: PublicApi;
  connection: AmbientConnection;
  config: AmbientConfig;
  db: AmbientDatabase;
}
declare function connect(config: AmbientConfig): AmbientConnection;
//#endregion
export { MyService, connect };"
`;

exports[`basic 1`] = `
"// basic.d.ts
//#region tests/fixtures/basic.d.ts
declare const foo: number;
type SomeType<T> = T;
type FooType = string;
interface Interface {}
declare function fn(arg0: SomeType<FooType>, opt: Interface): void;
declare enum Enum {
  A = 0,
  B = 1,
  C = 2
}
declare class Cls {
  foo: string;
  fn(e: Enum): void;
}
//#endregion
export { Cls, Enum, fn, foo };
// basic.js
//#region tests/fixtures/basic.ts
const foo = 42;
function fn(arg0, opt) {}
let Enum = /* @__PURE__ */ function(Enum) {
	Enum[Enum["A"] = 0] = "A";
	Enum[Enum["B"] = 1] = "B";
	Enum[Enum["C"] = 2] = "C";
	return Enum;
}({});
var Cls = class {
	foo;
	fn(e) {}
};

//#endregion
export { Cls, Enum, fn, foo };"
`;

exports[`cjs exports 1`] = `
"// cjs-exports.js

//#region tests/fixtures/cjs-exports.ts
var cjs_exports_default = 42;

//#endregion
module.exports = cjs_exports_default;"
`;

exports[`cjs exports 2`] = `
"// cjs-exports.d.ts
//#region tests/fixtures/cjs-exports.d.ts
declare const _default: number;
export = _default;"
`;

exports[`codeSplitting 1`] = `
"// entry.d.ts
import { t as shared1 } from "./shared1-chunk-DInpuBpE.js";

//#region tests/fixtures/manual-chunk/shared2.d.ts
declare const shared2 = "shared2";
//#endregion
export { shared1, shared2 };
// shared1-chunk-DInpuBpE.d.ts
//#region tests/fixtures/manual-chunk/shared1.d.ts
declare const shared1 = "shared1";
//#endregion
export { shared1 as t };"
`;

exports[`css.ts files 1`] = `
"// index.d.ts
//#region tests/fixtures/css-ts/file.css.d.ts
declare const myClass: string;
//#endregion
export { myClass };"
`;

exports[`cyclic import 1`] = `
"// a-B8uCZscZ.d.ts
//#region b.d.ts
declare class SomeClass<T extends SomeInterface<number>> {
  value: T;
  constructor(value: T);
  doSomething<T extends SomeInterface<number>>(value: T): T;
}
type SomeBoolean = boolean;
//#endregion
//#region a.d.ts
interface SomeInterface<T> {
  value: T;
}
type T = SomeBoolean;
//#endregion
export { SomeClass as i, T as n, SomeBoolean as r, SomeInterface as t };
// a.d.ts
import { n as T, t as SomeInterface } from "./a-B8uCZscZ.js";
export { SomeInterface, T };
// b.d.ts
import { i as SomeClass, r as SomeBoolean } from "./a-B8uCZscZ.js";
export { SomeBoolean, SomeClass };"
`;

exports[`declare module 1`] = `
"// declare-module.d.ts
//#region tests/fixtures/declare-module.d.ts
declare module "virtual" {
  const _default: string;
  export default _default;
}"
`;

exports[`dts input > custom chunk name 2`] = `
"// chunks/BCXvBysl-types.d.ts
//#region tests/fixtures/dts-multi-input/types.d.ts
interface User {
  id: string;
  name: string;
}
//#endregion
export { User as t };
// input1.d.ts
import { t as User } from "./chunks/BCXvBysl-types.js";

//#region tests/fixtures/dts-multi-input/input1.d.ts
interface ApiResponse {
  data: User;
}
//#endregion
export { ApiResponse };
// input2.d.ts
import { t as User } from "./chunks/BCXvBysl-types.js";

//#region tests/fixtures/dts-multi-input/input2.d.ts
interface UserWithAge extends User {
  age: number;
}
//#endregion
export { UserWithAge };"
`;

exports[`dts input > default chunk name 2`] = `
"// input1.d.mts
import { t as User } from "./types-B0jSiKC_.js";

//#region tests/fixtures/dts-multi-input/input1.d.ts
interface ApiResponse {
  data: User;
}
//#endregion
export { ApiResponse };
// input2.d.mts
import { t as User } from "./types-B0jSiKC_.js";

//#region tests/fixtures/dts-multi-input/input2.d.ts
interface UserWithAge extends User {
  age: number;
}
//#endregion
export { UserWithAge };
// types-B0jSiKC_.d.ts
//#region tests/fixtures/dts-multi-input/types.d.ts
interface User {
  id: string;
  name: string;
}
//#endregion
export { User as t };"
`;

exports[`dts input > input array 1`] = `
"// dts-input.d.ts
//#region tests/fixtures/dts-input.d.ts
declare class Foo {}
//#endregion
export { Foo };"
`;

exports[`dts input > input object 1`] = `
"// index.d.ts
//#region tests/fixtures/dts-input.d.ts
declare class Foo {}
//#endregion
export { Foo };"
`;

exports[`entryFileNames > custom chunk name 2`] = `
"// chunks/BCXvBysl-types.d.ts
//#region tests/fixtures/dts-multi-input/types.d.ts
interface User {
  id: string;
  name: string;
}
//#endregion
export { User as t };
// input1.d.ts
import { t as User } from "./chunks/BCXvBysl-types.js";

//#region tests/fixtures/dts-multi-input/input1.d.ts
interface ApiResponse {
  data: User;
}
//#endregion
export { ApiResponse };
// input2.d.ts
import { t as User } from "./chunks/BCXvBysl-types.js";

//#region tests/fixtures/dts-multi-input/input2.d.ts
interface UserWithAge extends User {
  age: number;
}
//#endregion
export { UserWithAge };"
`;

exports[`entryFileNames > default chunk name 2`] = `
"// input1.d.mts
import { t as Input2 } from "./input2-459dIHr0.js";

//#region tests/fixtures/alias/input1.d.ts
interface Input1 extends Input2 {
  input1: string;
}
declare const input1: Input1;
//#endregion
export { Input1, input1 };
// input2-459dIHr0.d.ts
//#region tests/fixtures/alias/shared.d.ts
interface Shared {
  shared: string;
}
declare const shared: Shared;
//#endregion
//#region tests/fixtures/alias/input2.d.ts
interface Input2 extends Shared {
  input2: string;
}
declare const input2: Input2;
//#endregion
export { input2 as n, Input2 as t };
// input2.d.mts
import { n as input2, t as Input2 } from "./input2-459dIHr0.js";
export { Input2, input2 };"
`;

exports[`export equals namespace 1`] = `
"// index.d.ts
//#region node_modules/mock-db/index.d.ts
declare function mockdb(): mockdb.Connection;
declare function mockdb(url: string): mockdb.Connection;
declare namespace mockdb {
  interface Connection {
    query(sql: string): Promise<Row[]>;
    close(): void;
  }
  interface Row {
    [key: string]: unknown;
  }
  interface Options {
    host: string;
    port: number;
  }
  class DatabaseError extends Error {
    code: string;
  } // Enum for testing qualified name replacement (like HTTPVersion.V1)
  const enum DriverType {
    Postgres = 1,
    MySQL = 2,
    SQLite = 3
  }
  interface UnusedType1 {
    foo: string;
  }
  interface UnusedType2 {
    bar: number;
  }
}
//#endregion
//#region index.d.ts
interface DbConfig {
  connection: mockdb.Connection;
  options?: mockdb.Options;
  defaultDriver: mockdb.DriverType.Postgres;
}
declare function runQuery(conn: mockdb.Connection, sql: string): Promise<mockdb.Row[]>;
declare class Database {
  private conn;
  private lastError?;
  constructor(conn: mockdb.Connection);
  getConnection(): mockdb.Connection;
  getLastError(): mockdb.DatabaseError | undefined;
}
type QueryResult = mockdb.Row[];
type IsError<T> = T extends mockdb.DatabaseError ? true : false;
type DriverType = mockdb.DriverType;
//#endregion
export { Database, DbConfig, type DriverType, IsError, QueryResult, runQuery };"
`;

exports[`export equals namespace with re-exports 1`] = `
"// index.d.ts
//#region node_modules/mock-logger/index.d.ts
// Mock logger module that simulates pino's export = namespace pattern
declare function logger(options?: logger.LoggerOptions): logger.Logger;
declare namespace logger {
  type Level = 'debug' | 'info' | 'warn' | 'error';
  interface LoggerOptions {
    level?: Level;
    name?: string;
  }
  type LogFn = (msg: string, ...args: unknown[]) => void;
  interface Bindings {
    [key: string]: unknown;
  }
  interface ChildLoggerOptions {
    level?: Level;
    bindings?: Bindings;
  }
  interface Logger {
    level: Level;
    info: LogFn;
    warn: LogFn;
    error: LogFn;
    debug: LogFn;
    child(bindings: Bindings, options?: ChildLoggerOptions): Logger;
  }
}
//#endregion
//#region node_modules/mock-framework/types/logger.d.ts
// Framework's own logger interface that uses the imported types
interface FrameworkLogger {
  level: logger.Level;
  info: logger.LogFn;
  warn: logger.LogFn;
  error: logger.LogFn;
  child(bindings: logger.Bindings, options?: logger.ChildLoggerOptions): FrameworkLogger;
}
interface FrameworkOptions {
  logger?: FrameworkLogger | logger.LoggerOptions | boolean;
}
type FrameworkLogFn = logger.LogFn;
type LogLevel = logger.Level;
type Bindings$1 = logger.Bindings;
type ChildLoggerOptions$1 = logger.ChildLoggerOptions;
type BaseLoggerOptions = logger.LoggerOptions;
//#endregion
//#region node_modules/mock-framework/index.d.ts
interface FrameworkInstance {
  listen(port: number): Promise<void>;
  close(): Promise<void>;
}
declare function createFramework(options?: FrameworkOptions): FrameworkInstance;
//#endregion
//#region index.d.ts
interface AppLogger {
  logger: FrameworkLogger;
}
declare class LoggerService {
  private logger;
  private level;
  constructor(logger: FrameworkLogger);
  log(fn: FrameworkLogFn, msg: string): void;
  withBindings(bindings: Bindings$1): FrameworkLogger;
  getLevel(): LogLevel;
}
//#endregion
export { AppLogger, type FrameworkLogFn, type FrameworkLogger, type LogLevel, LoggerService };"
`;

exports[`infer false branch 1`] = `
"// index.d.ts
//#region tests/fixtures/infer-false-branch/mod.d.ts
type U = "mod";
//#endregion
//#region tests/fixtures/infer-false-branch/index.d.ts
type U$1 = "local";
type Test<T> = T extends Array<infer U> ? (T extends Array<infer U2> ? U2 : U) : U$1;
//#endregion
export { Test, type U };"
`;

exports[`infer type parameter 1`] = `
"// infer-type-param.d.ts
//#region tests/fixtures/infer-type-param.d.ts
type Mapped<T> = T extends Record<string, infer U> ? U : never;
type Fn1<U = unknown> = () => Mapped<U>;
type Fn2<V = unknown> = () => Mapped<V>;
//#endregion
export { Fn1, Fn2 };"
`;

exports[`input alias 1`] = `
"// input2-BRYOrfUi.d.ts
//#region shared.d.ts
interface Shared {
  shared: string;
}
declare const shared: Shared;
//#endregion
//#region input2.d.ts
interface Input2 extends Shared {
  input2: string;
}
declare const input2: Input2;
//#endregion
export { input2 as n, Input2 as t };
// input2-Cn0-MVuN.js
//#region shared.ts
const shared = { shared: "shared" };

//#endregion
//#region input2.ts
const input2 = {
	...shared,
	input2: "input2"
};

//#endregion
export { input2 as t };
// output1.d.ts
import { t as Input2 } from "./input2-BRYOrfUi.js";

//#region input1.d.ts
interface Input1 extends Input2 {
  input1: string;
}
declare const input1: Input1;
//#endregion
export { Input1, input1 };
// output1.js
import { t as input2 } from "./input2-Cn0-MVuN.js";

//#region input1.ts
const input1 = {
	...input2,
	input1: "input1"
};

//#endregion
export { input1 };
// output2/index.d.ts
import { n as input2, t as Input2 } from "../input2-BRYOrfUi.js";
export { Input2, input2 };
// output2/index.js
import { t as input2 } from "../input2-Cn0-MVuN.js";

export { input2 };"
`;

exports[`manualChunks 1`] = `
"// entry.d.ts
import { t as shared1 } from "./shared1-chunk-DInpuBpE.js";

//#region tests/fixtures/manual-chunk/shared2.d.ts
declare const shared2 = "shared2";
//#endregion
export { shared1, shared2 };
// shared1-chunk-DInpuBpE.d.ts
//#region tests/fixtures/manual-chunk/shared1.d.ts
declare const shared1 = "shared1";
//#endregion
export { shared1 as t };"
`;

exports[`namespace re-exports types via direct exports 1`] = `
"// index.d.ts
// Simulates pino-std-serializers pattern
// Module exports types directly at module level
interface SerializedError {
  type: string;
  message: string;
  stack: string;
}
interface SerializedRequest {
  method: string;
  url: string;
  headers: Record<string, string>;
}
interface SerializedResponse {
  statusCode: number;
  headers: Record<string, string>;
}
declare function err(error: Error): SerializedError;
declare function req(request: any): SerializedRequest;
declare function res(response: any): SerializedResponse;
//#endregion
//#region index.d.ts
declare function formatError(err: Error): SerializedError;
declare namespace logger {
  const stdSerializers: {
    err: typeof err;
    req: typeof req;
    res: typeof res;
  };
  export { type SerializedError, type SerializedRequest, type SerializedResponse };
}
//#endregion
export { formatError, logger };"
`;

exports[`re-export from lib > both 1`] = `
"// a.d.ts
export * from "stub-lib";

//#region \\0rolldown/runtime.js

import * as import_stub_lib from "stub-lib";
//#endregion
export { import_stub_lib as t };
// b.d.ts
import { t as a_d_exports } from "./a.js";
type LibType = a_d_exports.LibType;
export { type LibType };"
`;

exports[`re-export from lib > onlyA 1`] = `
"// a.d.ts
export * from "stub-lib";"
`;

exports[`re-export from lib > onlyB 1`] = `
"// b.d.ts
import * as import_stub_lib from "stub-lib";
type LibType = import_stub_lib.LibType;
export { type LibType };"
`;

exports[`real css imports are externalized 1`] = `
"// index.d.ts
//#region tests/fixtures/css-real/index.d.ts
declare const foo: number;
//#endregion
export { foo };"
`;

exports[`resolve dts 1`] = `
"// index.d.ts
//#region tests/fixtures/resolve-dts/mod.d.ts
type Foo = string;
//#endregion
export { Foo };
// index.js
"
`;

exports[`side effects 1`] = `
"// index.d.ts
import "./mod.js";

//#region tests/fixtures/side-effects/index.d.ts
// mod.d.ts
//#region tests/fixtures/side-effects/mod.d.ts
declare global {
  let sideEffectExecuted: boolean;
}"
`;

exports[`sub namespace 1`] = `
"// sub-namespace.d.ts
//#region tests/fixtures/sub-namespace.d.ts
declare namespace Foo.Bar {
  export {};
}
//#endregion
export { Foo };"
`;

exports[`tree-shaking 1`] = `
"// index.d.ts
//#region tests/fixtures/tree-shaking/mod.d.ts
type A = string;
//#endregion
export { type A };
// index.js
"
`;

exports[`tsgo with custom path 1`] = `
"// basic.d.ts
//#region tests/fixtures/basic.d.ts
declare const foo: number;
type SomeType<T> = T;
type FooType = string;
interface Interface {}
declare function fn(arg0: SomeType<FooType>, opt: Interface): void;
declare enum Enum {
  A = 0,
  B = 1,
  C = 2
}
declare class Cls {
  foo: string;
  fn(e: Enum): void;
}
//#endregion
export { Cls, Enum, fn, foo };
// basic.js
//#region tests/fixtures/basic.ts
const foo = 42;
function fn(arg0, opt) {}
let Enum = /* @__PURE__ */ function(Enum) {
	Enum[Enum["A"] = 0] = "A";
	Enum[Enum["B"] = 1] = "B";
	Enum[Enum["C"] = 2] = "C";
	return Enum;
}({});
var Cls = class {
	foo;
	fn(e) {}
};

//#endregion
export { Cls, Enum, fn, foo };"
`;

exports[`tsx 1`] = `
"// tsx.d.ts
import { JSX } from "solid-js";

//#region tests/fixtures/tsx.d.ts
declare function createComponent(): JSX.HTMLAttributes<HTMLElement>;
//#endregion
export { createComponent };
// tsx.js
import { jsx } from "react/jsx-runtime";

//#region tests/fixtures/tsx.tsx
function createComponent() {
	return /* @__PURE__ */ jsx("div", {});
}

//#endregion
export { createComponent };"
`;

exports[`type-only export 1`] = `
"// index.d.ts
//#endregion
//#region tests/fixtures/type-only-export/mod.d.ts
declare class A {}
declare class B {}
declare namespace namespace_d_exports {
  export { ns };
}
declare const ns = 42;
//#endregion
//#region tests/fixtures/type-only-export/all.d.ts
declare const all = 42;
//#endregion
export { A as RuntimeA, type A as TypeA, A as TypeC, type B as TypeB, all, type namespace_d_exports as ns };"
`;
